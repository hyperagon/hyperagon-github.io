+++
title = 'LLM Test: Editor'
summary = 'Ask LLMs to make a text editor'
date = 2024-05-19T09:34:34+01:00
draft = false
tags = ['llm test', 'editor']
+++

This time I tried adding a [full page](https://wasimlorgat.com/posts/editor.html) on how to do it but the model reached the maximum tokens (thexe include both input and output).

```
# https://wasimlorgat.com/posts/editor.html

import curses
import sys
import argparse

class Window:
    def __init__(self, n_rows, n_cols, row=0, col=0):asked 
        self.n_rows = n_rows
        self.n_cols = n_cols
        self.row = row
        self.col = col

    @property
    def bottom(self):
        return self.row + self.n_rows - 1

    def up(self, cursor):
        if cursor.row == self.row - 1 and self.row > 0:
            self.row -= 1
            
    def down(self, buffer, cursor):
        if cursor.row == self.bottom + 1 and self.bottom < buffer.bottom:
            self.row += 1

    def translate(self, cursor):
        return cursor.row - self.row, cursor.col - self.col
        
    def horizontal_scroll(self, cursor, left_margin=5, right_margin=2):
        n_pages = cursor.col // (self.n_cols - right_margin)
        self.col = max(n_pages * self.n_cols - right_margin - left_margin, 0)

class Cursor:
    def __init__(self, row=0, col=0, col_hint=None):
        self.row = row
        self._col = col
        self._col_hint = col if col_hint is None else col_hint

    @property
    def col(self):
        return self._col

    @col.setter
    def col(self, col):
        self._col = col
        self._col_hint = col

    def _clamp_col(self, buffer):
        self._col = min(self._col_hint, len(buffer[self.row]))

    def up(self, buffer):
        if self.row > 0:
            self.row -= 1
            self._clamp_col(buffer)

    def down(self, buffer):
        if self.row < len(buffer) - 1:
            self.row += 1
            self._clamp_col(buffer)
            
    def left(self, buffer):
        if self.col > 0:
            self.col -= 1
        elif self.row > 0:
            self.row -= 1
            self.col = len(buffer[self.row])

    def right(self, buffer):
        if self.col < len(buffer[self.row]):
            self.col += 1
        elif self.row < buffer.bottom:
            self.row += 1
            self.col = 0

class Buffer:
    def __init__(self, lines):
        self.lines = lines

    def __len__(self):
        return len(self.lines)

    def __getitem__(self, index):
        return self.lines[index]
        
    @property
    def bottom(self):
        return len(self) - 1

    def insert(self, cursor, string):
        row, col = cursor.row, cursor.col
        current = self.lines.pop(row)
        new = current[:col] + string + current[col:]
        self.lines.insert(row, new)

    def split(self, cursor):
        row, col = cursor.row, cursor.col
        current = self.lines.pop(row)
        self.lines.insert(row, current[:col])
        self.lines.insert(row + 1, current[col:])

    def delete(self, cursor):
        row, col = cursor.row, cursor.col
        if row < len(self.lines):
            if col < len(self.lines[row]):
                # Delete within the line
                self.lines[row] = self.lines[row][:col] + self.lines[row][col+1:]
            else:
                # We're at the end of a line, merge with the next line if possible
                if row + 1 < len(self.lines):
                    self.lines[row] += self.lines.pop(row + 1)

def right(window, buffer, cursor):
    cursor.right(buffer)
    window.down(buffer, cursor)
    window.horizontal_scroll(cursor)
    
def left(window, buffer, cursor):
    cursor.left(buffer)
    window.up(cursor)
    window.horizontal_scroll(cursor)
    
def main(stdscr):
    #curses.curs_set(0)  # Hide the cursor
    stdscr.keypad(True) # Enable keypad mode

    parser = argparse.ArgumentParser()
    parser.add_argument("filename", nargs='?')  # Make filename optional
    args = parser.parse_args()

    if args.filename:
        try:
            with open(args.filename, 'r') as f:
                buffer = Buffer(f.read().splitlines())
        except FileNotFoundError:
            print(f"File not found: {args.filename}. Opening a new buffer.")
            buffer = Buffer([""])  # Start with an empty line for new files
    else:
        buffer = Buffer([""])  # Start with an empty line for no filename

    window = Window(curses.LINES - 1, curses.COLS - 1)
    cursor = Cursor()

    while True:
        stdscr.erase()
        for row, line in enumerate(buffer[window.row:window.row + window.n_rows]):
            if row == cursor.row - window.row and window.col > 0:
                line = "«" + line[window.col + 1:]
            if len(line) > window.n_cols:
                line = line[:window.n_cols - 1] + "»"
            stdscr.addstr(row, 0, line)
        stdscr.move(*window.translate(cursor))

        k = stdscr.getkey()
        if k in ("KEY_ESCAPE", '\x1b'):
            break  # Exit the loop instead of sys.exit(0)
        elif k == "KEY_UP":
            cursor.up(buffer)
            window.up(cursor)
            window.horizontal_scroll(cursor)
        elif k == "KEY_DOWN":
            cursor.down(buffer)
            window.down(buffer, cursor)
            window.horizontal_scroll(cursor)
        elif k == "KEY_LEFT":
            cursor.left(buffer)
            window.up(cursor)
            window.horizontal_scroll(cursor)
        elif k == "KEY_RIGHT":
            cursor.right(buffer)
            window.down(buffer, cursor)
            window.horizontal_scroll(cursor)
        elif k == "\n":
            buffer.split(cursor)
            right(window, buffer, cursor)
        elif k in ("KEY_DELETE", "\x04", "KEY_DC"):
            buffer.delete(cursor)
        elif k in ("KEY_BACKSPACE", "\x7f"):
            if cursor.col == 0 and cursor.row > 0:
                # If at the beginning of a line, merge with the previous line
                cursor.row -= 1
                cursor.col = len(buffer.lines[cursor.row])
                buffer.delete(cursor)
            elif cursor.col > 0:
                # Regular backspace within the line
                cursor.col -= 1
                buffer.delete(cursor)
        else:
            buffer.insert(cursor, k)
            for _ in k:
                right(window, buffer, cursor)

if __name__ == "__main__":
    curses.wrapper(main)
```

Then asked LLMs to add an

```
# https://wasimlorgat.com/posts/editor.htm
# 4 prompts

import curses
import sys
import argparse

class Window:
    def __init__(self, n_rows, n_cols, row=0, col=0):
        self.n_rows = n_rows
        self.n_cols = n_cols
        self.row = row
        self.col = col

    @property
    def bottom(self):
        return self.row + self.n_rows - 1

    def up(self, cursor):
        if cursor.row == self.row - 1 and self.row > 0:
            self.row -= 1
            
    def down(self, buffer, cursor):
        if cursor.row == self.bottom + 1 and self.bottom < buffer.bottom:
            self.row += 1

    def translate(self, cursor):
        return cursor.row - self.row, cursor.col - self.col
        
    def horizontal_scroll(self, cursor, left_margin=5, right_margin=2):
        n_pages = cursor.col // (self.n_cols - right_margin)
        self.col = max(n_pages * self.n_cols - right_margin - left_margin, 0)

class Cursor:
    def __init__(self, row=0, col=0, col_hint=None):
        self.row = row
        self._col = col
        self._col_hint = col if col_hint is None else col_hint

    @property
    def col(self):
        return self._col

    @col.setter
    def col(self, col):
        self._col = col
        self._col_hint = col

    def _clamp_col(self, buffer):
        self._col = min(self._col_hint, len(buffer[self.row]))

    def up(self, buffer):
        if self.row > 0:
            self.row -= 1
            self._clamp_col(buffer)

    def down(self, buffer):
        if self.row < len(buffer) - 1:
            self.row += 1
            self._clamp_col(buffer)
            
    def left(self, buffer):
        if self.col > 0:
            self.col -= 1
        elif self.row > 0:
            self.row -= 1
            self.col = len(buffer[self.row])

    def right(self, buffer):
        if self.col < len(buffer[self.row]):
            self.col += 1
        elif self.row < buffer.bottom:
            self.row += 1
            self.col = 0

class Buffer:
    def __init__(self, lines):
        self.lines = lines

    def __len__(self):
        return len(self.lines)

    def __getitem__(self, index):
        return self.lines[index]
        
    @property
    def bottom(self):
        return len(self) - 1

    def insert(self, cursor, string):
        row, col = cursor.row, cursor.col
        current = self.lines.pop(row)
        new = current[:col] + string + current[col:]
        self.lines.insert(row, new)

    def split(self, cursor):
        row, col = cursor.row, cursor.col
        current = self.lines.pop(row)
        self.lines.insert(row, current[:col])
        self.lines.insert(row + 1, current[col:])

    def delete(self, cursor):
        row, col = cursor.row, cursor.col
        if row < len(self.lines):
            if col < len(self.lines[row]):
                # Delete within the line
                self.lines[row] = self.lines[row][:col] + self.lines[row][col+1:]
            else:
                # We're at the end of a line, merge with the next line if possible
                if row + 1 < len(self.lines):
                    self.lines[row] += self.lines.pop(row + 1)

    def save(self, filename):
        with open(filename, 'w') as f:
            f.write('\n'.join(self.lines))
            
def right(window, buffer, cursor):
    cursor.right(buffer)
    window.down(buffer, cursor)
    window.horizontal_scroll(cursor)
    
def left(window, buffer, cursor):
    cursor.left(buffer)
    window.up(cursor)
    window.horizontal_scroll(cursor)
    

def show_menu(stdscr):
    curses.curs_set(0)  # Hide the cursor
    # Options for the menu
    menu = ['Return', 'Save', 'Exit']
    choice = -1
    current_row = 0

    def print_menu(stdscr, selected_row_idx):
        stdscr.clear()
        h, w = stdscr.getmaxyx()
        for idx, row in enumerate(menu):
            x = w // 2 - len(row) // 2
            y = h // 2 - len(menu) // 2 + idx
            if idx == selected_row_idx:
                stdscr.attron(curses.color_pair(1))
                stdscr.addstr(y, x, row)
                stdscr.attroff(curses.color_pair(1))
            else:
                stdscr.addstr(y, x, row)
        stdscr.refresh()

    # Initialize colors
    curses.start_color()
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)

    # Print the initial menu
    print_menu(stdscr, current_row)

    while True:
        key = stdscr.getch()

        if key == 27: # Escape = Return
            choice = -1
            break
        elif key == curses.KEY_UP:
            current_row = (current_row - 1) % len(menu)  # Wrap around
        elif key == curses.KEY_DOWN:
            current_row = (current_row + 1) % len(menu)  # Wrap around
        elif key == curses.KEY_ENTER or key in [10, 13]:
            choice = current_row
            break

        print_menu(stdscr, current_row)

    # Handle the selected action
    if choice == 0:
        return ""
    elif choice == 1:
        return "save"
    elif choice == 2:
        return "exit"
    else:
        return ""
    
def save_file(stdscr, buffer, filename):
    stdscr.clear()
    stdscr.addstr(0, 0, "Saving file...")
    stdscr.refresh()
    buffer.save(filename)
    stdscr.addstr(1, 0, "File saved successfully.")
    stdscr.refresh()
    stdscr.getch()
    
def main(stdscr):
    #curses.curs_set(0)  # Hide the cursor
    stdscr.keypad(True) # Enable keypad mode

    parser = argparse.ArgumentParser()
    parser.add_argument("filename", nargs='?')  # Make filename optional
    args = parser.parse_args()

    if args.filename:
        try:
            with open(args.filename, 'r') as f:
                buffer = Buffer(f.read().splitlines())
        except FileNotFoundError:
            print(f"File not found: {args.filename}. Opening a new buffer.")
            buffer = Buffer([""])  # Start with an empty line for new files
    else:
        buffer = Buffer([""])  # Start with an empty line for no filename

    window = Window(curses.LINES - 1, curses.COLS - 1)
    cursor = Cursor()

    while True:
        stdscr.erase()
        for row, line in enumerate(buffer[window.row:window.row + window.n_rows]):
            if row == cursor.row - window.row and window.col > 0:
                line = "«" + line[window.col + 1:]
            if len(line) > window.n_cols:
                line = line[:window.n_cols - 1] + "»"
            stdscr.addstr(row, 0, line)
        stdscr.move(*window.translate(cursor))

        k = stdscr.getkey()
        if k in ("KEY_ESCAPE", '\x1b'):
            action = show_menu(stdscr)

            if action == "save":
                save_file(stdscr, buffer, args.filename)
            elif action == "open":
                stdscr.addstr(2, 0, "File opened!")
            elif action == "exit":
                break
            

            curses.curs_set(1)
            stdscr.refresh()
        elif k == "KEY_UP":
            cursor.up(buffer)
            window.up(cursor)
            window.horizontal_scroll(cursor)
        elif k == "KEY_DOWN":
            cursor.down(buffer)
            window.down(buffer, cursor)
            window.horizontal_scroll(cursor)
        elif k == "KEY_LEFT":
            cursor.left(buffer)
            window.up(cursor)
            window.horizontal_scroll(cursor)
        elif k == "KEY_RIGHT":
            cursor.right(buffer)
            window.down(buffer, cursor)
            window.horizontal_scroll(cursor)
        elif k == "\n":
            buffer.split(cursor)
            right(window, buffer, cursor)
        elif k in ("KEY_DELETE", "\x04", "KEY_DC"):
            buffer.delete(cursor)
        elif k in ("KEY_BACKSPACE", "\x7f"):
            if cursor.col == 0 and cursor.row > 0:
                # If at the beginning of a line, merge with the previous line
                cursor.row -= 1
                cursor.col = len(buffer.lines[cursor.row])
                buffer.delete(cursor)
            elif cursor.col > 0:
                # Regular backspace within the line
                cursor.col -= 1
                buffer.delete(cursor)
        else:
            buffer.insert(cursor, k)
            for _ in k:
                right(window, buffer, cursor)

if __name__ == "__main__":
    curses.wrapper(main)
```
